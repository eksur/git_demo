1. Как обрабатывать NULL может устанавливаться на уровне сервера - фолс или нул. Если параметр ANSI_NULLS равен ON, все сравнения со значением NULL возвращают значение UNKNOWN. Когда SET ANSI_NULLS равняется OFF, сравнение любых значений с NULL вернет TRUE только в том случае, если сравниваемое значение тоже NULL. 

2. Физическое чтение запроса: проведения симантической проверки запроса, проверки что все ресурсы существуют в БД(тфблицы, функцииб столбцы) т.е. логический разбор, не требующий доступа к файлам БД - СУБД формирует план выполнения запроса - что нужно сделать что бы выполнить запрос - оптимизирует план выполнения исследуя различные способы: можно ли использовать индексы, с какой таблицы начать поиск - выбор одного из множества альтернативных планов - выполнение плана и кеширование плана.
Физическое стение коротко: Parsing-Binding-Optimization-Execution
Логическое чтение запроса: from-where-group-SELECT-order-over-distinct-top-insern,update,delete-output-union

3. CTE - вьюшка, которая создается и существует в рамках одного запроса, не как объект БД

4. Constraints - нужно для обеспечения согласованости БД(нет противоречивых данных): PK, FK, Unique, Check, NotNull(Default)

5. Оконные функции бывают: агрегатными(sum,min,msx,count,avg), ранжирования (rank-ранг для значений в группе, с пропуском значений,dense_rank-то же но без пропуска,row_number-увеличение на 1 для каждой строки в группе,ntile(N) весь набор делит на N групп), offset функции(LEAD, LAG, FIRST_VALUE, LAST_VALUE - в последних двух используем форточки(RANGE или ROWS с указанием битвин))

6. Джионы - иннер, outer, full, cross, тета(джоин по нерав1енству)

7. Типы сет запросов - UNION, UNION ALL, EXCEPT, INTERSECT

8. Разница между DELETE и TRUNCATE: TRUNCATE это DDL команда, почти не пишет лог транзакций только инфрмацию что таблица была удалена и создана заново(как бы), счетчик сбрасывается, если есть FK или индексированые вью то сперва их нужно удалять, нельзя откатить, нужны разрешения; DELETE - DML, для каждой удаленной строки заносить информацию в лог транзакции, не обнуляет счетчик, активирует тригеры, используется с WHERE(или без), возможен откат

9. Временная таблица и табличная переменная:
-создание темповой #, ##, переменной @ и @@ 
-переменые нельзя создать через Select Into
-у переменных нет ограничения форейнг ключа
-переменной нельзя создать индекс, но можно ограничение
-переменные не имею связных объектов в БД как тригеры,форейнг ключей
-темповая имеет статискику а переменая нет - оптимизатор видит переменую как однострочную таблицу, что влияет на план, поэтому лучше использовать для маленьких таблиц
-темповая существует в рамках подключения, глабольная доступна для других подключений, переменная только в рамках пачки, пакета
-переменная создается  через декалрирование, темповая как обычная таблица
-на темповой можно выполнять DDL такие как ALTER, CREATE,DROP
-темповая участвует в блокировках, транзакциях, пишут информацю в в журнал танзакций-ROLLBACK повлияет на темповую но не на переменную
-темповую нельзя использовать в функции, а переменную можно
-темповую можно использовать в динамическом скл, а переменную нельзя(т.к. другой батч)

10.XML - тип данных, структура состоит из тегов, у которых есть атрибуты и значения, могут быть только атрибуты без значения и наоборот, или вообще ничего. XML может быть асоциированая с XSD схемой или нет(но лучше да) - это описание структуры, с типами данных элементов, обязательности. По схеме проверяем структуру. Данные из запроса в виде XML преобразуем с помощью FOR XML:
AUTO - автоматом генерирует имена тегов, по именам таблиц, внутри название колонки = значение
RAW - имена не присваиваются - название элемента создается как row, если не указать своё, внутри название колонки = значение
PATH - добавляет иерархию по колонкам - т.е. атрибуты стновятся тегами, значения атрибутов - значениями тегов, есть рутовый элемент = row если не указать своего, в SELECT можно указывать иерархию как алиас столбца: i.ItemNumber AS 'LineItems/Item/@ItemNo' = <LineItems><Item ItemNo=""></Item></LineItems>
Доп параметры - ELEMENTS - разбиваем по элементам как будто PATH, ROOT('имя корня')
Для трансформации XML в таблицу:
-используем функцию sp_xml_preparedocument, а затем SELECT * FROM OPENXML(указатель на XML в памяти,адрес тега,что вернуть - атрибуты,значения и т.д.) 
-используем XQuery - для получения значения из XML используем value('(корень/тег/@трибут)','тип данных') - значение атрибута тега или value('(корень/тег)','тип данных') - значение тега; nodes() - возвращает набор строк по указанному пути; метод exists() проверяет существование определенного значения по пути, работа с данными в XML с помощью query()-теги как столбцы for $тег in путь, и изменение с помощью modify()

11.MERGE все записи новые в сорс добавлены в таргет, записи которых нет в сорс будут удалены из таргет, изменения по одинаковым строкам сорса будут синхронизированы с таргетом(апдейт). Для исключения коализий если мерж в хранимой процедуре, то в мерже нужно использовать WITH HOLDLOCK. ПОЧЕМУ МЕРЖ МЕДЛЕНЫЙ?

12.Dynamic SQL это обычная строка, которая после преобразования сервером и подстановки всех значений выполняется как скл запрос. Выполнить можно двумя способами: 
execute(@sql) - подвержена скл инъекциям, неявное приведение типов переменных внутри запроса, запрос кешируется с подставленными значениями переменных, т.е. при повторном вызове с другим значением оптимизатор скорее всего снова будет рассчитывать план
sp_executesql @sql, N'@var INT', @var=@varvalue, @varOUT=@varOUT OUTPUT - системная процедура, на вход пеердаем строку запроса, объявление переменных с типами и сами значения переменных, так же есть возможность получить выходное значение. Отличие от execute - защита от инъекций, выполнение без явного преобразования, план кешируется для параметризированного запроса и при изменении значений не пересчитывается(иногда плохо, т.к. передать можно в переменную что-то что кардинально сломает план, например увеличит число логических чтений)

13.FUNCTIONS - ограничена обработка ошибок(нельзя использовать try catch, raiseerror), нельзя использовать динамический скл, инструкцию SET, временные таблицы, нельзя вызвать процедуру, вернуть несколько наборов
ВИДЫ: скаляная - возвращает одно значение, фукнции инлайн - возвращает табличное значение, многооператорная - возвращает табличное значение. Разница двух последних в том. что сервер их по разному обрабатывает - инлайн как вью, т.е. сервер вставляет текст функции в запрос и потмо всё выполняет, многооператорная выполняется как ЧЯ для плана запроса, план посроится один раз даже если функция менялась.

14. Конструктор строк определяет набор значений строк, которые вставляются в таблицу, позволяет множественную вставку в одной дмл операции. Может быть определено в VALUES

15. Индексы и типы индексов. 
Основные два типа - кластерный и некластерный. Оба постоены на схеме б-три(сбалансированные деревья), которая гарантирует что до любой строки таблицы дойдём за одинаковое количество операций. Дерево содержит корень, промежуточные уровни, по которофм находим лиф левелы. 
Кластерный индекс это есть таблица. В кластерном индексе лиф левел уже содержит данные строки, т.е. дополнительной операции чтения не нужно. Так же таблица всегда логически отсортирована по кластерному индексу, т.е. он может быть только один для таблицы и чем короче(желательно одна колонка, интовая), тем лучше, что б не занимать память. Поиск по индексу: index seek(+range scan) когда по индексу находим конкретное значение или диапазон, index scan(ordered) когда находим мин или макс значение в индексе и перебираем его до конца по страницам. 
Некластерный - это дополнительный объект к таблице. Но на уровне листьев лежит значение поля индекса(например фамилия) и ROWID(это обычно значение кластерного индекса). Т.е. после получения значения ROWID переходим в кластерный индекс и найти данные (операция key lookup).
Композитный - может быть кластерный и нет, индекс по нескольким колонкам, если кластерный то сотрирует по колонкам слева направо, т.е. работа по индексу будет идти ТОЛЬКО если заполнена левая часть индекса, т.е. первое поле на котором основан индекс должно быть в запросе, иначе индекс не работает. 
Покрывающий(каверед) - некластерный, когда на уровне листьев сохраняем значение доп колонки(с помощью команды include, например есть индекс по фамилии, а хотим сразу и имя получить, без доп операций чтения, то добавляем в индекс колонку имя). По сути мы можем получить все данные не задействуя операции чтения таблицы.
Фильтрующий(фильтеред) - некластерный, используем когда хотим индекс не по всем значениям поля, а по каким то определенным(используется команда  where и условие).
Уникальный индекс - индексы на колонки с PK и UK, при создании PK автоматом создается уникальный кластерный индекс, но можно казатаь настройку и создать не кластерный.

16. Материлизированная вьюшка. 
Это индексированая вьюшка. Создаем вью со скемабиндинг, создаем кластерный индекс на вью и данные будут сохранятся в индексе в БД(один раз посчитали и сохранили). ОЧень много ограничений. Нельзя использовать аутер джоины, дистинксты, топ, что бы всё пересчитывалось быстро.

17. Транзакции и свойсва транзакций. 
Это логическая единица работы. Свойства ACID(Atomicity,Consistency,Isolation,Durability). 
Атомарность - в транзакции выполняется всё или ничего.
Непротиворечивость - как транзакция закончена все данные в БД остаются валидны, целостность не нарушена
Изоляция - транзакции модифицируют данные изолировано друг от друга, чтение проходит в зависимости от уровня изоляции
Выживаемость - как только транзакция завершилась все данные сохранились. Т.е. если произошел сбой, данные транзакции либо откатились либо полностью заверешились.
Существуют системные и пользовательские транзакции.
@@TRANCOUNT - количество открытых транзакций
XACT_STATE() - состояние транзакции, 0 - нет открытых, 1 - открыта и всё хорошо, -1 - открыта, но ошибка и нужно откатывать.
Типы транзакции:
явная (бегин тран, комит и ролбэк пишем сами)
неявная: автокомит(по дефолту, это любая DML) и неявная(редко используется, включается командой SET IMPLICIT_TRANSACTION ON, есть неявный бегин тран, но коммита нет)
Может быть вложеной, коммит на каждую, ролбэк откатывает всё, даже закомиченую внутрению.
SAVE TRAN NameOFSavePoint
ROLLBACK TRAN NameOFSavePoint

18. Уровни изоляции и блокировки
Основные виды блокировок:
Shared Lock(S) они совместимы друг с другом, ставятся при чтении данных(смотреть могут сколько угодно людей)
Exclusive Lock(X) возникает при модификации данных, может быть только одна
Update(U) транзакция готова перейти в эксклюзивную блокировку и определяет строки, которые нужно залочить
Преднамеренные блокировки:
Intent shared(IS) 
Intent exvlusive(IX)
Shared with intent exclusive(SIX)
Служат для того, что бы предварительно занять место для шаред или эксклюзивной блокировки. При этом устанавлюваются на объектах по иерархии выше, чем объект, которых транзакция намеревается залочить. Так другие транзакции не будут просматривать все уровни иерархии на наличие блокировок. Например хотим залочить строку, ставим преднамеренную блокировку на странице данных и таблице.
Блокировка схемы (Sch-M - блокировка модификаци схемы, Sch-S - блокировка устойчивости схемы) - первая применяется при физическом изменении БД(запрет просмотров при например добавлении столбца), вторая во время любого запроса запрещает DDL.

Уровни изоляции (SET TRANSACTION ISOLATION LEVEL):
READ UNCOMMITED - возможность читать незафиксированые данные(грязное чтение), не использует шэред блокировки.
READ COMMITED - по дефолту используется, использует шэред блокировки, если данные изменились и незакомичены, транзакция ожидает пока не будут зафиксированы. Т.е. селект как только выполнился снял шерэд блокировку и делай что хочешь с таблицей.
REPEATABLE READ - шэред блокировка ставится вначале транзакции и снимается в конце, т.е. если мы сделали селект, но транзакцию не закрыли, то шерэд будет висеть дальше, но только на строках которые мы прочитали. Это не касатеся добавления новых строк или удалении, отсюда возникают фантомные чтения
SERIALIZABLE - то же + не даст добавить новые данные в таблицу.

READ COMMITED SNAPSHOT - работаем не с самими данными, а с каким то слепком, включается на уровне БД. ТРанзакция при изменении данных ставит эксклюзивные блокировки, но при этом ставит сылку в tempdb и когда мы хотим считать данные, то идем по ссылке и считываем данные там
SNAPSHOT - в отличие от предыдущего полностью копирует данные в tempdb там с ними работает и возвращает всё оттуда

19. Планы запросов - эстимейтед и актуал. Разница в количестве читаемых строк - эстимейтед план строится до выполнеия запроса на основе статисктики таблиц, актуальный план тот который был выбран непосредстевнно при исполнении запроса и сколько действительно строк было прочитано. В идеале эстимейтед и актуал количество строк должно как можно ближе совпадать.

Table Scan - проход по всей таблице
Clustered Index Scan - сканирование всего кластерного индекса
Clustered Index Seek - поиск значения по кластерному индексу
Index Scan - просмотр всего некластерного индекса
Index Seek - поиск значения по некластерному индексу
RID Lookup - возникает при некластерном индексе на таблице типа куча, ищем ROWID(=FileID:PageNum:SlotNum) строки по нему строку
Key Lookup - возникает при некластерном индексе на кластерной таблице

Nested Loops - по одной строке таблице ищем соответсвующие строки во втрой таблице и т.д., хорошо для небольших
Merge Join - сортируем две таблицы и начинаем сравнение, хорошо для больши и уже отсортированых таблиц, т.к. операция сортировки дорогая
Hash Join - по меньшей таблице создаем хэши и уже по ним сравниваем строки из второй. Трудоемко создание хешей, но быстро остальная часть

Stream Agregate - для вычисления агрегатов для сортированных строк. Вычисление значения для каждой группы значений.
Hash Agregate - по каждой строке вычисляем хэш, идём в хэш таблицу, сравниваем хэши и уже совершаем операции нужные(сумма или увеличение счетчика)
Filter - фильтрация данных применяющаяся после отбора строк
Sort - сортировка данных после отбора, очень дорогостоящая операция, видим-настораживаемся.

20. Количество чтений логических и физических. Логическое - количество чтений из памяти закешированой таблицы, физический - когда читаем с диска. Когда есть физическое чтение это говорит о том, что страница данных не закеширована, а если много физ чтений, в том числе страницы одни и те же читаются часто физически, то это значит что серверу не хватает памяти для них и постоянно приходится общаться с жестким диском. При физическом чтении сервер может читать страницы рид-ахеад, вперед предполагая что они нам понадобятся.

21. Статистика (DBCC SHOW_STATISTICS(N'Schema.Table', N'column or index name')) сервер создает статистику по умолчанию на колонки с индексами и при настройке - на остальных колонках. Основная информация - колонка по которой построена, количество строк в таблице, когда обновление последний раз статистики, Содержит например гистограмму - берутся мин и макс значения из таблицы и все значения таблицы, всё разбивается на 200 диапазонов, для каждого диапазона есть верхнее значение, количетво строк в диапазоне, сколько из них дистинкт и т.д. Статистика обновляется автоматически при изменении сколько то процентов таблицы(динамическая величина). 

22. DMV(Dynamic Managment View) - системные вью, по которым можно получить полезную системную инфу. Важные 
dm_os_sys_info инфа о системе: размер памяти и т.д., 
dm_os_waiting_tasks: задачи которые выполняются или подвисли, можно вычислить блокировки, 
dm_exec_session: запросы выполняемые в данный момент, 
dm_exec_query_stats: запрос какой и как выполнялся(количесвтво выполнений, чтений,логических операций ввода вывода), dm_db_index_usage_stats: статистика работы индексов, можно мониторить те которые не используются, dm_db_missing_index_(details,columns,groups,group_stats): предположение сервера каких индексов не хватает, dm_exec_cached_plans, 
dm_exec_sql_text,
dm_exec_requests,
dm_tran_locks - смотрим блокировки.

23. Селектитвность индекса
Селективность индекса = количество уникальных ключей / количество строк. Сервер учитывает свою внутрению статистику для расчета селективности. У уникальных индексов = 1. Чем больше дистинкт значений тем выше селективность, чем выше селективность тем полезнее индекс для оптимизатора. Изменение порядка ключевых колонок могут увеличить селективность индекса, но иногда только в частном случае запроса, а для остальных план ухудшиться. Инвертное значение селективности - денсити(плотность), чем выше плотность тем ниже селективность.